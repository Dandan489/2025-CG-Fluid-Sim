#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel Reorder
#pragma kernel ReorderCopyback
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions
#pragma kernel CalculateDriftVelocity
#pragma kernel CalculateVolumeFraction
#pragma kernel UpdateVolumeFraction
#pragma kernel CalculateCMT

// Includes
#include "./FluidMaths2D.hlsl"
#include "./SpatialHash.hlsl"

static const int NumThreads = 64;

// Buffers
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> Densities; // Density, Near Density

// New Buffers
RWStructuredBuffer<float> Mass;
RWStructuredBuffer<float> PressureDelta;
RWStructuredBuffer<float2> Acceleration;
RWStructuredBuffer<float2> DriftVelocity_0;
RWStructuredBuffer<float2> DriftVelocity_1;
RWStructuredBuffer<float2> VolumeFraction;
RWStructuredBuffer<float2> VolumeFractionRate;

// Spatial hashing
RWStructuredBuffer<uint> SpatialKeys;
RWStructuredBuffer<uint> SpatialOffsets;
StructuredBuffer<uint> SortedIndices;

// Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
// const float viscosityStrength;
const float2 boundsSize;
const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

const float2 obstacleSize;
const float2 obstacleCentre;

const float2 phaseDensity;
const float2 phaseMass;
const float tau; // 0.000001
const float sigma; // 0.001
const float2 viscosityStrength;

float DensityKernel(float dst, float radius)
{
	return SpikyKernelPow2(dst, radius);
}

float NearDensityKernel(float dst, float radius)
{
	return SpikyKernelPow3(dst, radius);
}

float DensityDerivative(float dst, float radius)
{
	return DerivativeSpikyPow2(dst, radius);
}

float NearDensityDerivative(float dst, float radius)
{
	return DerivativeSpikyPow3(dst, radius);
}

float ViscosityKernel(float dst, float radius)
{
	return SmoothingKernelPoly6(dst, smoothingRadius);
}

float2 CalculateDensity(float2 pos, float mass)
{
	int2 originCell = GetCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	// Neighbour search
	for (int i = 0; i < 9; i++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			density += DensityKernel(dst, smoothingRadius) * mass;
			nearDensity += NearDensityKernel(dst, smoothingRadius) * mass;
		}
	}
	if(density == 0.0){
		return float2(100, mass);
	}

	return float2(density, nearDensity);
}

float PressureFromDensity(float density, float2 volumeFraction)
{
	return (density - dot(volumeFraction, phaseDensity)) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
	return nearPressureMultiplier * nearDensity;
}

float2 ExternalForces(float2 pos, float2 velocity)
{
	// Gravity
	float2 gravityAccel = float2(0.0, gravity);
	
	// Input interactions modify gravity
	if (interactionInputStrength != 0) {
		float2 inputPointOffset = interactionInputPoint - pos;
		float sqrDst = dot(inputPointOffset, inputPointOffset);
		if (sqrDst < interactionInputRadius * interactionInputRadius)
		{
			float dst = sqrt(sqrDst);
			float edgeT = (dst / interactionInputRadius);
			float centreT = 1 - edgeT;
			float2 dirToCentre = inputPointOffset / dst;

			float gravityWeight = 1 - (centreT * saturate(interactionInputStrength / 10));
			float2 accel = gravityAccel * gravityWeight + dirToCentre * centreT * interactionInputStrength;
			accel -= velocity * centreT;
			return accel;
		}
	}

	return gravityAccel;
}


void HandleCollisions(uint particleIndex)
{
	float2 pos = Positions[particleIndex];
	float2 vel = Velocities[particleIndex];

	// Keep particle inside bounds
	const float2 halfSize = boundsSize * 0.5;
	float2 edgeDst = halfSize - abs(pos);

	if (edgeDst.x <= 0)
	{
		pos.x = halfSize.x * sign(pos.x);
		vel.x *= -1 * collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		pos.y = halfSize.y * sign(pos.y);
		vel.y *= -1 * collisionDamping;
	}

	// Collide particle against the test obstacle
	const float2 obstacleHalfSize = obstacleSize * 0.5;
	float2 obstacleEdgeDst = obstacleHalfSize - abs(pos - obstacleCentre);

	if (obstacleEdgeDst.x >= 0 && obstacleEdgeDst.y >= 0)
	{
		if (obstacleEdgeDst.x < obstacleEdgeDst.y) {
			pos.x = obstacleHalfSize.x * sign(pos.x - obstacleCentre.x) + obstacleCentre.x;
			vel.x *= -1 * collisionDamping;
		}
		else {
			pos.y = obstacleHalfSize.y * sign(pos.y - obstacleCentre.y) + obstacleCentre.y;
			vel.y *= -1 * collisionDamping;
		}
	}

	// Update position and velocity
	Positions[particleIndex] = pos;
	Velocities[particleIndex] = vel;
}

void CalcDriftVelocity(uint particleIndex)
{
	float2 pos = Positions[particleIndex];
	float density_m = dot(VolumeFraction[particleIndex], phaseDensity);
	float2 massFrac = float2(0.0, 0.0);
	massFrac[0] = VolumeFraction[particleIndex][0] * phaseDensity[0] / density_m;
	massFrac[1] = VolumeFraction[particleIndex][1] * phaseDensity[1] / density_m;

    int2 originCell = GetCell2D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float inertiaTerm_0 = (phaseDensity[0] - dot(massFrac, phaseDensity));
    float inertiaTerm_1 = (phaseDensity[1] - dot(massFrac, phaseDensity));
    float2 pressureGradient_0 = float2(0.0, 0.0);
    float2 pressureGradient_1 = float2(0.0, 0.0);
    float2 volumeFracGradient_0 = float2(0.0, 0.0);
    float2 volumeFracGradient_1 = float2(0.0, 0.0);
    float2 Vel_m0;
	float2 Vel_m1;
    // Neighbour search
    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(originCell + offsets2D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex ++;

            // Skip if looking at self
            if (neighbourIndex == particleIndex) continue;
            
            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;
            
            float2 neighbourPos = PredictedPositions[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float dst = sqrt(sqrDstToNeighbour);
            float2 dirToNeighbour = dst > 0 ?- offsetToNeighbour / dst : -float2(0.0, 1.0);

            float neighbourDensity = Densities[neighbourIndex][0];
			
            float neighbourPressure = PressureFromDensity(Densities[neighbourIndex][0], VolumeFraction[neighbourIndex]);
			float particlePressure = PressureFromDensity(Densities[particleIndex][0], VolumeFraction[particleIndex]);

            float neighbourVolumeFrac_0 = VolumeFraction[neighbourIndex][0];
            float neighbourVolumeFrac_1 = VolumeFraction[neighbourIndex][1];
			float number = 0;

			// make toggle to enable DEMO
            pressureGradient_0 += dirToNeighbour * (Mass[neighbourIndex]/neighbourDensity)
                                *(neighbourPressure * neighbourVolumeFrac_0  - particlePressure * VolumeFraction[particleIndex][0]) * SpikyKernelPow2(dst, smoothingRadius);
            pressureGradient_1 += dirToNeighbour * (Mass[neighbourIndex]/neighbourDensity)
                                *(neighbourPressure * neighbourVolumeFrac_1 - particlePressure *  VolumeFraction[particleIndex][1]) * SpikyKernelPow2(dst, smoothingRadius);
            
            volumeFracGradient_0 += dirToNeighbour * (Mass[neighbourIndex]/neighbourDensity)
                                *(neighbourVolumeFrac_0 - VolumeFraction[particleIndex][0]) * SpikyKernelPow2(dst, smoothingRadius);
            volumeFracGradient_1 += dirToNeighbour * (Mass[neighbourIndex]/neighbourDensity)
                                *(neighbourVolumeFrac_1 - VolumeFraction[particleIndex][1]) * SpikyKernelPow2(dst, smoothingRadius);
        }
    }
    float2 pressureGradient_avg = massFrac[0] * pressureGradient_0 + massFrac[1] * pressureGradient_1;
	float2 volumeFracGradient_avg_q = float2(0.0, 0.0);
	if(VolumeFraction[particleIndex][0] > 0.01){
		volumeFracGradient_avg_q += massFrac[0] / VolumeFraction[particleIndex][0] * volumeFracGradient_0;
	}
	if(VolumeFraction[particleIndex][1] > 0.01){
		volumeFracGradient_avg_q += massFrac[1] / VolumeFraction[particleIndex][1] * volumeFracGradient_1;
	}

	if(VolumeFraction[particleIndex][0] > 0.01){
		Vel_m0 = tau * inertiaTerm_0 * Acceleration[particleIndex] - tau * (pressureGradient_0 - pressureGradient_avg) 
                - sigma * (volumeFracGradient_0/VolumeFraction[particleIndex][0] - volumeFracGradient_avg_q);
	}
	else{
		Vel_m0 = float2(0.0, 0.0);
	}

	if(VolumeFraction[particleIndex][1] > 0.01){
		Vel_m1 = tau * inertiaTerm_1 * Acceleration[particleIndex] - tau * (pressureGradient_1 - pressureGradient_avg) 
                - sigma * (volumeFracGradient_1/VolumeFraction[particleIndex][1] - volumeFracGradient_avg_q);   
	}
	else{
		Vel_m1 = float2(0.0, 0.0);
	}
	
	DriftVelocity_0[particleIndex] = Vel_m0;
	DriftVelocity_1[particleIndex] = Vel_m1;

	Acceleration[particleIndex] = float2(0.0, 0.0);
}

float2 CalculateVolumeFracRate(uint particleIndex)
{
	float2 pos = Positions[particleIndex];
    int2 originCell = GetCell2D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float2 volumeFracRate = float2(0.0, 0.0);
    float2 AggregateMotion = float2(0.0, 0.0);
    float2 Discrepancy = float2(0.0, 0.0);
    float2 volumeFracGradient_0 = float2(0.0, 0.0);
    float2 volumeFracGradient_1 = float2(0.0, 0.0);
	
    // Neighbour search
    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(originCell + offsets2D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex ++;

            // Skip if looking at self
            if (neighbourIndex == particleIndex) continue;
            
            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;
            
            float2 neighbourPos = PredictedPositions[neighbourIndex];
            float2 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float dst = sqrt(sqrDstToNeighbour);
            float2 dirToNeighbour = dst > 0 ? -offsetToNeighbour / dst : -float2(0.0, 1.0);
			
            float neighbourDensity = Densities[neighbourIndex][0];

			float neighbourVolumeFrac_0 = VolumeFraction[neighbourIndex][0];
            float neighbourVolumeFrac_1 = VolumeFraction[neighbourIndex][1];

            AggregateMotion[0] += (Mass[particleIndex]/neighbourDensity) * (VolumeFraction[particleIndex][0] + VolumeFraction[neighbourIndex][0]) * 0.5 * 
                                  dot(dirToNeighbour, Velocities[neighbourIndex] - Velocities[particleIndex]) * SpikyKernelPow2(dst, smoothingRadius);

			if(isnan(AggregateMotion[0])){
				volumeFracRate[0] = 100;
				volumeFracRate[1] = neighbourDensity;
				return volumeFracRate;
			}
			
            AggregateMotion[1] += (Mass[particleIndex]/neighbourDensity) * (VolumeFraction[particleIndex][1] + VolumeFraction[neighbourIndex][1]) * 0.5 * 
                                  dot(dirToNeighbour, Velocities[neighbourIndex] - Velocities[particleIndex]) * SpikyKernelPow2(dst, smoothingRadius);
            
			if(isnan(AggregateMotion[1])){
				volumeFracRate[0] = 200;
				volumeFracRate[1] = neighbourDensity;
				return volumeFracRate;
			}

            Discrepancy[0] += (Mass[particleIndex]/neighbourDensity) * SpikyKernelPow2(dst, smoothingRadius) *
                            dot(VolumeFraction[particleIndex][0] * DriftVelocity_0[particleIndex] + VolumeFraction[neighbourIndex][0] * DriftVelocity_0[neighbourIndex], dirToNeighbour);
            
			if(isnan(Discrepancy[0])){
				volumeFracRate[0] = 300;
				volumeFracRate[1] = neighbourDensity;
				return volumeFracRate;
			}

			Discrepancy[1] += (Mass[particleIndex]/neighbourDensity) * SpikyKernelPow2(dst, smoothingRadius) *
                            dot(VolumeFraction[particleIndex][1] * DriftVelocity_1[particleIndex] + VolumeFraction[neighbourIndex][1] * DriftVelocity_1[neighbourIndex], dirToNeighbour);
			
			if(isnan(Discrepancy[1])){
				volumeFracRate[0] = 400;
				volumeFracRate[1] = neighbourDensity;
				return volumeFracRate;
			}

            volumeFracGradient_0 += dirToNeighbour * (Mass[neighbourIndex]/neighbourDensity)
                                *(neighbourVolumeFrac_0 - VolumeFraction[particleIndex][0]) * SpikyKernelPow2(dst, smoothingRadius);
            volumeFracGradient_1 += dirToNeighbour * (Mass[neighbourIndex]/neighbourDensity)
                                *(neighbourVolumeFrac_1 - VolumeFraction[particleIndex][1]) * SpikyKernelPow2(dst, smoothingRadius);
        }
    }

    volumeFracRate[0] = -AggregateMotion[0] - Discrepancy[0] - dot(volumeFracGradient_0, Velocities[particleIndex]);
    volumeFracRate[1] = -AggregateMotion[1] - Discrepancy[1] - dot(volumeFracGradient_1, Velocities[particleIndex]);
    return volumeFracRate;
}

void UpdateVolumeFracRate(uint particleIndex)
{
    float minFraction = 0.0000000001;
	float slowDown = 0.0000000001;
    float2 newVolumeFrac = VolumeFraction[particleIndex] + VolumeFractionRate[particleIndex] * deltaTime;
	newVolumeFrac = float2(max(0.0, newVolumeFrac[0]), max(0.0, newVolumeFrac[1])); 

    if (newVolumeFrac[0] < minFraction && newVolumeFrac[1] < minFraction)
    {
        newVolumeFrac[0] = minFraction;
        newVolumeFrac[1] = minFraction;
    }

    float sum = newVolumeFrac[0] + newVolumeFrac[1];
    newVolumeFrac = newVolumeFrac / sum; //Rescale to 1
	float2 deltaVolumeFrac = newVolumeFrac - VolumeFraction[particleIndex]; 
    VolumeFraction[particleIndex] = newVolumeFrac; // update volume fraction
    float deltaPressure = (-pressureMultiplier) * dot(deltaVolumeFrac, phaseDensity);
    PressureDelta[particleIndex] += deltaPressure;

	Mass[particleIndex] = dot(phaseMass, VolumeFraction[particleIndex]);
}

[numthreads(NumThreads,1,1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// External forces (gravity and input interaction)
	Velocities[id.x] += ExternalForces(Positions[id.x], Velocities[id.x]) * deltaTime;

	// Predict
	const float predictionFactor = 1 / 120.0;
	PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * predictionFactor;
}

[numthreads(NumThreads,1,1)]
void UpdateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	uint index = id.x;
	int2 cell = GetCell2D(PredictedPositions[index], smoothingRadius);
	uint hash = HashCell2D(cell);
	uint key = KeyFromHash(hash, numParticles);
	SpatialKeys[id.x] = key;
}

RWStructuredBuffer<float2> SortTarget_Positions;
RWStructuredBuffer<float2> SortTarget_PredictedPositions;
RWStructuredBuffer<float2> SortTarget_Velocities;

//New SortTarget Buffers
RWStructuredBuffer<float> SortTarget_Mass;
RWStructuredBuffer<float2> SortTarget_Acceleration;
RWStructuredBuffer<float2> SortTarget_VolumeFraction;

[numthreads(NumThreads,1,1)]
void Reorder (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	uint sortedIndex = SortedIndices[id.x];
	SortTarget_Positions[id.x] = Positions[sortedIndex];
	SortTarget_PredictedPositions[id.x] = PredictedPositions[sortedIndex];
	SortTarget_Velocities[id.x] = Velocities[sortedIndex];
	SortTarget_Mass[id.x] = Mass[sortedIndex];
	SortTarget_Acceleration[id.x] = Acceleration[sortedIndex];
	SortTarget_VolumeFraction[id.x] = VolumeFraction[sortedIndex];
}


[numthreads(NumThreads,1,1)]
void ReorderCopyback (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	Positions[id.x] = SortTarget_Positions[id.x];
	PredictedPositions[id.x] = SortTarget_PredictedPositions[id.x];
	Velocities[id.x] = SortTarget_Velocities[id.x];
	Mass[id.x] = SortTarget_Mass[id.x];
	Acceleration[id.x] = SortTarget_Acceleration[id.x];
	VolumeFraction[id.x] = SortTarget_VolumeFraction[id.x];
}


[numthreads(NumThreads,1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float2 pos = PredictedPositions[id.x];
	Densities[id.x] = CalculateDensity(pos, Mass[id.x]);
}

[numthreads(NumThreads,1,1)]
void CalculatePressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float density_m = dot(VolumeFraction[id.x], phaseDensity);
	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density, VolumeFraction[id.x]) + PressureDelta[id.x];
	float nearPressure = NearPressureFromDensity(densityNear);
	float2 pressureForce = 0;
	
	float2 pos = PredictedPositions[id.x];
	int2 originCell = GetCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 9; i ++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;

			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;
			
			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float dst = sqrt(sqrDstToNeighbour);
			float2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float2(0.0, 1.0);

			float neighbourDensity = Densities[neighbourIndex][0];
			float neighbourNearDensity = Densities[neighbourIndex][1];
			float neighbourPressure = PressureFromDensity(neighbourDensity, VolumeFraction[neighbourIndex]) + PressureDelta[neighbourIndex];
			float neighbourNearPressure = NearPressureFromDensity(neighbourNearDensity);

			float sharedPressure = (pressure + neighbourPressure) * 0.5;
			float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

			pressureForce += dirToNeighbour * DensityDerivative(dst, smoothingRadius) * Mass[id.x] * sharedPressure / neighbourDensity;
			pressureForce += dirToNeighbour * NearDensityDerivative(dst, smoothingRadius) * Mass[id.x] * sharedNearPressure / neighbourNearDensity;
		}
	}

	float2 acceleration = pressureForce / density_m;
	Velocities[id.x] += acceleration * deltaTime;
	Acceleration[id.x] -= acceleration;
}



[numthreads(NumThreads,1,1)]
void CalculateViscosity (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	

	float2 pos = PredictedPositions[id.x];
	int2 originCell = GetCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	float2 viscosityForce = 0;
	float2 velocity = Velocities[id.x];

	float density_m = dot(VolumeFraction[id.x], phaseDensity);
	float2 viscosity_i = dot(VolumeFraction[id.x], viscosityStrength);
	
	for (int i = 0; i < 9; i ++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;

			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			float dst = sqrt(sqrDstToNeighbour);
			float2 neighbourVelocity = Velocities[neighbourIndex];
			float neighbourDensity = Densities[neighbourIndex][0];
			float viscosity_j = dot(VolumeFraction[neighbourIndex], viscosityStrength);
			viscosityForce += (-1)*(Mass[neighbourIndex]/neighbourDensity)*(viscosity_i + viscosity_j)*(neighbourVelocity - velocity) * SpikyKernelPow2(dst, smoothingRadius);
		}
	}
	Velocities[id.x] += (viscosityForce/density_m) * deltaTime;
	Acceleration[id.x] -= (viscosityForce/density_m);
}

[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	// float2 change;
	if(abs(Velocities[id.x][0] * deltaTime) > 0.10){
		Velocities[id.x][0] = sign(Velocities[id.x][0]) * 0.10 / deltaTime;
	}
	if(abs(Velocities[id.x][1] * deltaTime) > 0.10){
		Velocities[id.x][1] = sign(Velocities[id.x][1]) * 0.10 / deltaTime;
	}
	// change[0] = max(min(Velocities[id.x][0] * deltaTime, 0.005), -0.005);
	// change[1] = max(min(Velocities[id.x][1] * deltaTime, 0.005), -0.005);
	
	Positions[id.x] += Velocities[id.x] * deltaTime;
	HandleCollisions(id.x);
}

[numthreads(NumThreads, 1, 1)]
void CalculateDriftVelocity(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	CalcDriftVelocity(id.x);
}

[numthreads(NumThreads, 1, 1)]
void CalculateVolumeFraction(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	VolumeFractionRate[id.x] = CalculateVolumeFracRate(id.x);
}

[numthreads(NumThreads, 1, 1)]
void UpdateVolumeFraction(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	UpdateVolumeFracRate(id.x);
}

[numthreads(NumThreads,1,1)]
void CalculateCMT (uint3 id : SV_DispatchThreadID) //CMT: convective momentum transfer (T_Dm)
{
	if (id.x >= numParticles) return;
	
		
	float2 pos = PredictedPositions[id.x];
	int2 originCell = GetCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density_m = dot(VolumeFraction[id.x], phaseDensity);
	float2 CMTForce = 0;
	float2 u_m0i = DriftVelocity_0[id.x];
	float2 u_m1i = DriftVelocity_1[id.x];  

	for (int i = 0; i < 9; i ++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;

			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			float dst = sqrt(sqrDstToNeighbour);
			float2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float2(0.0, 1.0);

			float2 neighbourVelocity = Velocities[neighbourIndex];
			float neighbourDensity = Densities[neighbourIndex][0];
			float2 u_m0j = DriftVelocity_0[neighbourIndex];
			float2 u_m1j = DriftVelocity_1[neighbourIndex];
			float2 CMT_term1 = 
			phaseDensity[0]*(VolumeFraction[neighbourIndex][0] * u_m0j * dot(dirToNeighbour, u_m0j) * SpikyKernelPow2(dst, smoothingRadius)
							+ VolumeFraction[id.x][0] * u_m0i * dot(dirToNeighbour, u_m0i) * SpikyKernelPow2(dst, smoothingRadius));
			float2 CMT_term2 = 
			phaseDensity[1]*(VolumeFraction[neighbourIndex][1] * u_m1j * dot(dirToNeighbour, u_m1j) * SpikyKernelPow2(dst, smoothingRadius)
							+ VolumeFraction[id.x][1] * u_m1i * dot(dirToNeighbour, u_m1i) * SpikyKernelPow2(dst, smoothingRadius));

			CMTForce += (Mass[neighbourIndex]/neighbourDensity) * (CMT_term1 + CMT_term2);
		}

	}
	// float maxCMT = 100;
	// float minCMT = -100;
	// float2 acc = float2(max(min(CMTForce[0], maxCMT), minCMT), max(min(CMTForce[1], maxCMT), minCMT));
	Velocities[id.x] += (CMTForce / density_m) * deltaTime;
	Acceleration[id.x] -= (CMTForce / density_m);
}
