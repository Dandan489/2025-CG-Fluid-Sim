#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel Reorder
#pragma kernel ReorderCopyBack;
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions
#pragma kernel UpdateDensityTexture
#pragma kernel UpdateWhiteParticles
#pragma kernel WhiteParticlePrepareNextFrame
#pragma kernel CalculateDriftVelocity
#pragma kernel CalculateVolumeFraction
#pragma kernel UpdateVolumeFraction
#pragma kernel CalculateCMT

// Includes
#include "./FluidMaths3D.hlsl"
#include "./SpatialHash3D.hlsl"

static const int ThreadGroupSize = 256;


// Buffers
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> PredictedPositions;
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float2> Densities; // Density, Near Density

// New Buffers
RWStructuredBuffer<float> Mass;
RWStructuredBuffer<float> PressureDelta;
RWStructuredBuffer<float3> Acceleration;
RWStructuredBuffer<float3> DriftVelocity_0;
RWStructuredBuffer<float3> DriftVelocity_1;
RWStructuredBuffer<float2> VolumeFraction;
RWStructuredBuffer<float2> VolumeFractionRate;

// Spatial hashing
RWStructuredBuffer<uint> SpatialKeys;
RWStructuredBuffer<uint> SpatialOffsets;
StructuredBuffer<uint> SortedIndices;

RWStructuredBuffer<float3> Debug;

// Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float simTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
//const float viscosityStrength;
const float edgeForce;
const float edgeForceDst;
const float3 boundsSize;

const float4x4 localToWorld;
const float4x4 worldToLocal;

const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

// Multi phase settings
const float2 phaseDensity;
const float2 phaseMass;
const float tau;
const float sigma;
const float2 viscosityStrength;
const float mass;
const bool miscible;

// Volume texture settings
RWTexture3D<float> DensityMap;
const uint3 densityMapSize;

// ---- Foam, spray, and bubbles ----
struct WhiteParticle
{
    float3 position;
    float3 velocity;
    float remainingLifetime;
    float scale;
};

RWStructuredBuffer<WhiteParticle> WhiteParticles;
RWStructuredBuffer<WhiteParticle> WhiteParticlesCompacted;
// Holds 2 values:
// [0] = ActiveCount: (num particles alive or spawned in at the start of the frame)
// [1] = SurvivorCount: (num particles surviving to the next frame -- copied into compact buffer)
RWStructuredBuffer<uint> WhiteParticleCounters;
const uint MaxWhiteParticleCount;
const float whiteParticleDeltaTime;

const float3 trappedAirParams;
const float2 kineticEnergyParams;
const float bubbleBuoyancy;
const int bubbleClassifyMinNeighbours;
const int sprayClassifyMaxNeighbours;
const float bubbleScale;
const float bubbleScaleChangeSpeed;

float PressureFromDensity(float density, float2 volumeFraction) //change this by adding volume fraction
{
	return (density - dot(volumeFraction, phaseDensity)) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
    return nearDensity * nearPressureMultiplier;
}


float Remap01(float val, float minVal, float maxVal)
{
    return saturate((val - minVal) / (maxVal - minVal));
}

void ResolveCollisions(inout float3 pos, inout float3 vel, float collisionDamping)
{
    // Transform position/velocity to the local space of the bounding box (scale not included)
    float3 posLocal = mul(worldToLocal, float4(pos, 1)).xyz;
    float3 velocityLocal = mul(worldToLocal, float4(vel, 0)).xyz;

    // Calculate distance from box on each axis (negative values are inside box)
    const float3 halfSize = 0.5;
    const float3 edgeDst = halfSize - abs(posLocal);

    // Resolve collisions
    if (edgeDst.x <= 0)
    {
        posLocal.x = halfSize.x * sign(posLocal.x);
        velocityLocal.x *= -1 * collisionDamping;
    }
    if (edgeDst.y <= 0)
    {
        posLocal.y = halfSize.y * sign(posLocal.y);
        velocityLocal.y *= -1 * collisionDamping;
    }
    if (edgeDst.z <= 0)
    {
        posLocal.z = halfSize.z * sign(posLocal.z);
        velocityLocal.z *= -1 * collisionDamping;
    }

    // Transform resolved position/velocity back to world space
    pos = mul(localToWorld, float4(posLocal, 1)).xyz;
    vel = mul(localToWorld, float4(velocityLocal, 0)).xyz;
}

[numthreads(ThreadGroupSize, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    // External forces (gravity)
    Velocities[id.x] += float3(0, gravity, 0) * deltaTime;

    // Predict
    PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * 1 / 120.0;
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    uint index = id.x;
    int3 cell = GetCell3D(PredictedPositions[index], smoothingRadius);
    uint hash = HashCell3D(cell);
    uint key = KeyFromHash(hash, numParticles);

    SpatialKeys[id.x] = key;
}


RWStructuredBuffer<float3> SortTarget_Positions;
RWStructuredBuffer<float3> SortTarget_PredictedPositions;
RWStructuredBuffer<float3> SortTarget_Velocities;

//New SortTarget Buffers
RWStructuredBuffer<float> SortTarget_Mass;
RWStructuredBuffer<float3> SortTarget_Acceleration;
RWStructuredBuffer<float2> SortTarget_VolumeFraction;

[numthreads(ThreadGroupSize, 1, 1)]
void Reorder(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    uint sortedIndex = SortedIndices[id.x];
    SortTarget_Positions[id.x] = Positions[sortedIndex];
    SortTarget_PredictedPositions[id.x] = PredictedPositions[sortedIndex];
    SortTarget_Velocities[id.x] = Velocities[sortedIndex];
    SortTarget_Mass[id.x] = Mass[sortedIndex];
    SortTarget_Acceleration[id.x] = Acceleration[sortedIndex];
    SortTarget_VolumeFraction[id.x] = VolumeFraction[sortedIndex];
}

[numthreads(ThreadGroupSize, 1, 1)]
void ReorderCopyBack(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    Positions[id.x] = SortTarget_Positions[id.x];
    PredictedPositions[id.x] = SortTarget_PredictedPositions[id.x];
    Velocities[id.x] = SortTarget_Velocities[id.x];
    Mass[id.x] = SortTarget_Mass[id.x];
	Acceleration[id.x] = SortTarget_Acceleration[id.x];
	VolumeFraction[id.x] = SortTarget_VolumeFraction[id.x];
}
// TODO:
// 1. add mass (done)
float2 CalculateDensitiesAtPoint(float3 pos)
{
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float density = 0;
    float nearDensity = 0;

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius)
                continue;

            // Calculate density and near density
            float dst = sqrt(sqrDstToNeighbour);
            density += DensityKernel(dst, smoothingRadius) * mass;
            nearDensity += NearDensityKernel(dst, smoothingRadius) * mass;
        }
    }

    return float2(density, nearDensity);
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 pos = PredictedPositions[id.x];
    float2 densities = CalculateDensitiesAtPoint(pos);

    Densities[id.x] = densities;
}

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result;
}

float RandomValue(inout uint state)
{
    return NextRandom(state) / 4294967295.0; // 2^32 - 1
}

// Thanks to https://math.stackexchange.com/a/4112622
// Calculates arbitrary normalized vector that is perpendicular to the given direction
float3 CalculateOrthonormal(float3 dir)
{
    float a = sign((sign(dir.x) + 0.5) * (sign(dir.z) + 0.5));
    float b = sign((sign(dir.y) + 0.5) * (sign(dir.z) + 0.5));
    float3 orthoVec = float3(a * dir.z, b * dir.z, -a * dir.x - b * dir.y);
    return normalize(orthoVec);
}

//TODO:
// 1. density ->density_m  (done)
// 2. mass (done)
// 3. foam
[numthreads(ThreadGroupSize, 1, 1)]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    // Calculate pressure
    float density_m =  dot(VolumeFraction[id.x], phaseDensity);
    float density = Densities[id.x][0];
    float densityNear = Densities[id.x][1];
    float pressure = PressureFromDensity(density, VolumeFraction[id.x]) + PressureDelta[id.x];
    float nearPressure = NearPressureFromDensity(densityNear);
    float3 pressureForce = 0;
    float3 velocity = Velocities[id.x];

    float3 pos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    int neighbourCount = 0;

    // Foam variables
    float weightedVelocityDifference = 0;


    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == id.x) continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float densityNeighbour = Densities[neighbourIndex][0];
            float nearDensityNeighbour = Densities[neighbourIndex][1];
            float neighbourPressure = PressureFromDensity(densityNeighbour, VolumeFraction[neighbourIndex]);
            float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

            float sharedPressure = (pressure + neighbourPressure) / 2;
            float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

            float dstToNeighbour = sqrt(sqrDstToNeighbour);
            float3 dirToNeighbour = dstToNeighbour > 0 ? offsetToNeighbour / dstToNeighbour : float3(0, 1, 0);
            neighbourCount++;

            // Update pressure force
            pressureForce += dirToNeighbour * DensityDerivative(dstToNeighbour, smoothingRadius) * mass * sharedPressure / densityNeighbour;
            pressureForce += dirToNeighbour * NearDensityDerivative(dstToNeighbour, smoothingRadius) * mass * sharedNearPressure / nearDensityNeighbour;

            // // ---- White Particle 'Trapped Air' Calculation ----
            // float3 relativeVelocity = velocity - Velocities[neighbourIndex];
            // float relativeVelocityMagnitude = length(relativeVelocity);
            // float3 relativeVelocityDir = relativeVelocity / max(0.000001, relativeVelocityMagnitude);
            // // 0 if moving in opposite directions; up to 2 if moving directly toward one another
            // float convergeWeight = 1 - dot(relativeVelocityDir, -dirToNeighbour);
            // // 1 when distance between particles is 0, down to 0 when distance reaches the smoothing radius
            // float influence = 1 - min(1, dstToNeighbour / smoothingRadius);
            // // Sum up weighted velocity diff between current particle and each of its surrounding neighbours
            // weightedVelocityDifference += relativeVelocityMagnitude * convergeWeight * influence;
        }
    }

    float3 acceleration = pressureForce / density_m;
    float3 velocityNew = velocity + acceleration * deltaTime;
    Velocities[id.x] = velocityNew;
    Acceleration[id.x] -= acceleration;

    // Quick test -- apply some drag to airborne fluid particles
    // if (neighbourCount < 8)
    // {
    //     Velocities[id.x] -= Velocities[id.x] * deltaTime * 0.75;
    // }


    //// ---- Handle spawning of white particles from the current fluid particle ----
    //uint rngState = dot(asuint(float4(pos, simTime)), uint4(19349669, 83492837, 73856131, 4785773));
    //if (id.x == 0) WhiteParticleCounters[1] = 0; // Reset survivor counter

    //float trappedAirFactor = trappedAirParams[0] * Remap01(weightedVelocityDifference, trappedAirParams[1], trappedAirParams[2]);
    //float kineticEnergyFactor = Remap01(dot(velocity, velocity), kineticEnergyParams[0], kineticEnergyParams[1]);
    //float particleSpawnFactor = trappedAirFactor * kineticEnergyFactor * deltaTime;

    //// Determine number of white particles to spawn. For example if the spawn factor is 3.7
    //// then we will spawn at least 3 particles, with a 70% chance of spawning a 4th particle
    //int particleSpawnCount = floor(particleSpawnFactor);
    //float fractionalSpawnRemainder = particleSpawnFactor - particleSpawnCount;
    //if (RandomValue(rngState) < fractionalSpawnRemainder) particleSpawnCount += 1;

    ////uint targ = NextRandom(rngState) % 4096;

    ////InterlockedAdd(WhiteParticleCounters[targ], 1);

    //if (particleSpawnCount > 0)
    //{
    //    uint particleIndex;
    //    InterlockedAdd(WhiteParticleCounters[0], (uint)particleSpawnCount, particleIndex);
    //    particleSpawnCount = min(particleSpawnCount, MaxWhiteParticleCount - particleIndex - 1);

    //    float3 cylinderBase = pos;
    //    float3 cylinderTop = pos + velocityNew * deltaTime; // height of cylinder determined by fluid velocity
    //    float3 cylinderAxisA = CalculateOrthonormal(velocityNew); // arbitrary direction along base of cylinder
    //    float3 cylinderAxisB = normalize(cross(cylinderAxisA, velocityNew));
    //    float cylinderRadius = smoothingRadius;
    //    float clusterMin, clusterMax;
    //    for (int spawnIndex = 0; spawnIndex < particleSpawnCount; spawnIndex++)
    //    {
    //        float randomAngle = RandomValue(rngState) * 2 * 3.1415;
    //        float3 offsetDir = cos(randomAngle) * cylinderAxisA + sin(randomAngle) * cylinderAxisB;
    //        float3 baseOffset = sqrt(RandomValue(rngState)) * cylinderRadius * offsetDir; // random point on cylinder base
    //        float3 spawnPos = cylinderBase + baseOffset + (cylinderTop - cylinderBase) * RandomValue(rngState);

    //        float dissolveTimeMin = 5;
    //        float dissolveTimeMax = 15;
    //        float lifetime = lerp(dissolveTimeMin, dissolveTimeMax, RandomValue(rngState));

    //        // Spawn new particle
    //        WhiteParticle whiteParticle;
    //        whiteParticle.position = spawnPos;
    //        whiteParticle.velocity = velocityNew + baseOffset;
    //        whiteParticle.remainingLifetime = lifetime;
    //        whiteParticle.scale = (bubbleScale + 1) / 2;
    //        WhiteParticles[particleIndex + spawnIndex] = whiteParticle;
    //    }
    //}
}

// TODO : Change the viscosity force
[numthreads(ThreadGroupSize, 1, 1)]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 pos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;

    float3 viscosityForce = 0;
    float3 velocity = Velocities[id.x];

    float density_m = dot(VolumeFraction[id.x], phaseDensity);
	float viscosity_i = dot(VolumeFraction[id.x], viscosityStrength);
    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;


            // Skip if looking at self
            if (neighbourIndex == id.x)
                continue;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius)
                continue;

            // Calculate viscosity
            float dst = sqrt(sqrDstToNeighbour);
            float3 neighbourVelocity = Velocities[neighbourIndex];
            float neighbourDensity = Densities[neighbourIndex][0];
			float viscosity_j = dot(VolumeFraction[neighbourIndex], viscosityStrength);
			viscosityForce += (mass)*(viscosity_i + viscosity_j)*(neighbourVelocity - velocity) * SpikyKernelPow2(dst, smoothingRadius);
        }
    }
    Velocities[id.x] += (viscosityForce/density_m) * deltaTime;
    Acceleration[id.x] -= (viscosityForce/density_m);
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 vel = Velocities[id.x];
    float3 pos = Positions[id.x];
    pos += vel * deltaTime;

    ResolveCollisions(pos, vel, collisionDamping);

    // Write results
    Positions[id.x] = pos;
    Velocities[id.x] = vel;
}

[numthreads(8, 8, 8)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= densityMapSize.x || id.y >= densityMapSize.y || id.z >= densityMapSize.z)
        return;

    // Convert threadID to a world-space position, and sample the fluid density at that point
    float3 texturePos = id / (densityMapSize - 1.0);
    float3 worldPos = (texturePos - 0.5) * boundsSize;
    DensityMap[id] = CalculateDensitiesAtPoint(worldPos)[0];
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateWhiteParticles(uint3 id : SV_DispatchThreadID)
{
    // Early exit if thread index exceeds particle count
    if (id.x >= min(MaxWhiteParticleCount, WhiteParticleCounters[0])) return;

    // Update particle
    float deltaTime = whiteParticleDeltaTime;
    WhiteParticle particle = WhiteParticles[id.x];

    // -- Neighbour fluid partices ---
    int3 originCell = GetCell3D(particle.position, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    int neighbourCount = 0;
    float3 velocitySum = 0;
    float weightSum = 0;

    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - particle.position;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour < sqrRadius)
            {
                float dstToNeighbour = sqrt(sqrDstToNeighbour);
                float influenceWeight = SmoothingKernelPoly6(dstToNeighbour, smoothingRadius);

                // Add up velocities of nearby fluid particles, weighted smoothly by distance.
                // Also add up the weights so that we can compute the average fluid velocity.
                velocitySum += Velocities[neighbourIndex] * influenceWeight;
                weightSum += influenceWeight;

                neighbourCount += 1;
            }
        }
    }

    // -- Classify --
    bool isSpray = neighbourCount <= sprayClassifyMaxNeighbours;
    bool isBubble = neighbourCount >= bubbleClassifyMinNeighbours;
    bool isFoam = !(isSpray || isBubble);

    // Foam is transported by the fluid
    if (isFoam)
    {
        // We want the foam to be carried by the fluid (not just accelerated by it),
        // so the velocity is directly set to the average velocity of surrounding fluid.
        particle.velocity = velocitySum / weightSum;
        // Dissolve the foam over time
        particle.remainingLifetime -= deltaTime;
    }
    // Bubbles are accelerated by the surrounding fluid, and moved upwards due to buoyancy
    else if (isBubble)
    {
        const float fluidAccelMul = 3; // How fast the bubble accelerates to match velocity with fluid
        float3 accelerationBuoyancy = float3(0, gravity, 0) * (1 - bubbleBuoyancy);
        float3 accelerationFluid = (velocitySum / weightSum - particle.velocity) * fluidAccelMul;
        particle.velocity += (accelerationBuoyancy + accelerationFluid) * deltaTime;
    }
    // Spray is affected by gravity and drag
    else if (isSpray)
    {
        const float dragMultiplier = 0.04;
        float sqrSpeed = dot(particle.velocity, particle.velocity);
        float3 drag = -normalize(particle.velocity) * sqrSpeed * dragMultiplier;
        particle.velocity += (float3(0, gravity, 0) + drag) * deltaTime;
    }

    float targetScale = isBubble ? bubbleScale : 1;
    particle.scale = lerp(particle.scale, targetScale, deltaTime * bubbleScaleChangeSpeed);
    particle.position += particle.velocity * deltaTime;

    const float collisionDampening = 0.1;
    ResolveCollisions(particle.position, particle.velocity, collisionDampening);
    WhiteParticles[id.x] = particle;

    // Compact the surviving particles into temporary buffer
    if (particle.remainingLifetime > 0)
    {
        uint survivorIndex;
        InterlockedAdd(WhiteParticleCounters[1], 1, survivorIndex);
        WhiteParticlesCompacted[survivorIndex] = particle;
    }
}


[numthreads(ThreadGroupSize, 1, 1)]
void WhiteParticlePrepareNextFrame(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= MaxWhiteParticleCount) return;

    // Copy the surviving particles back into the main particle buffer
    if (id.x < WhiteParticleCounters[1])
    {
        WhiteParticles[id.x] = WhiteParticlesCompacted[id.x];
    }

    // Set active particle count to the survivor count
    if (id.x == 0)
    {
        WhiteParticleCounters[0] = WhiteParticleCounters[1];
    }
}

//TODO : 
// 1. Drift velocity
// 2. CMT force
// 3. Calculate volume fraction 
// 4. Update volume fraction
// 5.  
void CalcDriftVelocity(uint particleIndex)
{
    float3 pos = Positions[particleIndex];
    float density_m = dot(VolumeFraction[particleIndex], phaseDensity);
    float2 massFrac = float2(0.0, 0.0);
    massFrac[0] = VolumeFraction[particleIndex][0] * phaseDensity[0] / density_m;
    massFrac[1] = VolumeFraction[particleIndex][1] * phaseDensity[1] / density_m;

    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float inertiaTerm_0 = (phaseDensity[0] - dot(massFrac, phaseDensity));
    float inertiaTerm_1 = (phaseDensity[1] - dot(massFrac, phaseDensity));
    float3 pressureGradient_0 = float3(0.0, 0.0, 0.0);
    float3 pressureGradient_1 = float3(0.0, 0.0, 0.0);
    float3 volumeFracGradient_0 = float3(0.0, 0.0, 0.0);
    float3 volumeFracGradient_1 = float3(0.0, 0.0, 0.0);
    float3 Vel_m0;
    float3 Vel_m1;
    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == particleIndex) continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float dst = sqrt(sqrDstToNeighbour);
            float3 dirToNeighbour = dst > 0 ? -offsetToNeighbour / dst : -float3(0.0, 1.0, 0.0);

            float neighbourDensity = Densities[neighbourIndex][0];

            float neighbourPressure = PressureFromDensity(Densities[neighbourIndex][0], VolumeFraction[neighbourIndex]);
            float particlePressure = PressureFromDensity(Densities[particleIndex][0], VolumeFraction[particleIndex]);

            float neighbourVolumeFrac_0 = VolumeFraction[neighbourIndex][0];
            float neighbourVolumeFrac_1 = VolumeFraction[neighbourIndex][1];
            float number = 0;

            // make toggle to enable DEMO
            if (miscible) {
                pressureGradient_0 += dirToNeighbour * (mass / neighbourDensity)
                    * (neighbourPressure * neighbourVolumeFrac_0 - particlePressure * VolumeFraction[particleIndex][0]) * SpikyKernelPow2(dst, smoothingRadius);
                pressureGradient_1 += dirToNeighbour * (mass / neighbourDensity)
                    * (neighbourPressure * neighbourVolumeFrac_1 - particlePressure * VolumeFraction[particleIndex][1]) * SpikyKernelPow2(dst, smoothingRadius);
            }
            else {
                pressureGradient_0 += dirToNeighbour * (mass / neighbourDensity)
                    * (neighbourPressure - particlePressure) * SpikyKernelPow2(dst, smoothingRadius);
                pressureGradient_1 += dirToNeighbour * (mass / neighbourDensity)
                    * (neighbourPressure - particlePressure) * SpikyKernelPow2(dst, smoothingRadius);
            }

            volumeFracGradient_0 += dirToNeighbour * (mass / neighbourDensity)
                * (neighbourVolumeFrac_0 - VolumeFraction[particleIndex][0]) * SpikyKernelPow2(dst, smoothingRadius);
            volumeFracGradient_1 += dirToNeighbour * (mass / neighbourDensity)
                * (neighbourVolumeFrac_1 - VolumeFraction[particleIndex][1]) * SpikyKernelPow2(dst, smoothingRadius);
        }
    }
    float3 pressureGradient_avg = massFrac[0] * pressureGradient_0 + massFrac[1] * pressureGradient_1;
    float3 volumeFracGradient_avg_q = float3(0.0, 0.0, 0.0);
    if (VolumeFraction[particleIndex][0] > 0.01) {
        volumeFracGradient_avg_q += massFrac[0] / VolumeFraction[particleIndex][0] * volumeFracGradient_0;
    }
    if (VolumeFraction[particleIndex][1] > 0.01) {
        volumeFracGradient_avg_q += massFrac[1] / VolumeFraction[particleIndex][1] * volumeFracGradient_1;
    }

    if (VolumeFraction[particleIndex][0] > 0.01) {
        Vel_m0 = tau * inertiaTerm_0 * Acceleration[particleIndex] - tau * (pressureGradient_0 - pressureGradient_avg)
            - sigma * (volumeFracGradient_0 / VolumeFraction[particleIndex][0] - volumeFracGradient_avg_q);
    }
    else {
        Vel_m0 = float3(0.0, 0.0, 0.0);
    }

    if (VolumeFraction[particleIndex][1] > 0.01) {
        Vel_m1 = tau * inertiaTerm_1 * Acceleration[particleIndex] - tau * (pressureGradient_1 - pressureGradient_avg)
            - sigma * (volumeFracGradient_1 / VolumeFraction[particleIndex][1] - volumeFracGradient_avg_q);
    }
    else {
        Vel_m1 = float3(0.0, 0.0, 0.0);
    }

    DriftVelocity_0[particleIndex] = Vel_m0;
    DriftVelocity_1[particleIndex] = Vel_m1;

    Acceleration[particleIndex] = float3(0.0, 0.0, 0.0);
}

float2 CalculateVolumeFracRate(uint particleIndex)
{
    float3 pos = Positions[particleIndex];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float2 volumeFracRate = float2(0.0, 0.0);
    float2 AggregateMotion = float2(0.0, 0.0);
    float2 Discrepancy = float2(0.0, 0.0);
    float3 volumeFracGradient_0 = float3(0.0, 0.0, 0.0);
    float3 volumeFracGradient_1 = float3(0.0, 0.0, 0.0);

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == particleIndex) continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float dst = sqrt(sqrDstToNeighbour);
            float3 dirToNeighbour = dst > 0 ? -offsetToNeighbour / dst : -float3(0.0, 1.0, 0.0);

            float neighbourDensity = Densities[neighbourIndex][0];

            float neighbourVolumeFrac_0 = VolumeFraction[neighbourIndex][0];
            float neighbourVolumeFrac_1 = VolumeFraction[neighbourIndex][1];

            AggregateMotion[0] += (mass / neighbourDensity) * (VolumeFraction[particleIndex][0] + VolumeFraction[neighbourIndex][0]) * 0.5 *
                dot(dirToNeighbour, Velocities[neighbourIndex] - Velocities[particleIndex]) * SpikyKernelPow2(dst, smoothingRadius);

            AggregateMotion[1] += (mass / neighbourDensity) * (VolumeFraction[particleIndex][1] + VolumeFraction[neighbourIndex][1]) * 0.5 *
                dot(dirToNeighbour, Velocities[neighbourIndex] - Velocities[particleIndex]) * SpikyKernelPow2(dst, smoothingRadius);

            Discrepancy[0] += (mass / neighbourDensity) * SpikyKernelPow2(dst, smoothingRadius) *
                dot(VolumeFraction[particleIndex][0] * DriftVelocity_0[particleIndex] + VolumeFraction[neighbourIndex][0] * DriftVelocity_0[neighbourIndex], dirToNeighbour);

            Discrepancy[1] += (mass / neighbourDensity) * SpikyKernelPow2(dst, smoothingRadius) *
                dot(VolumeFraction[particleIndex][1] * DriftVelocity_1[particleIndex] + VolumeFraction[neighbourIndex][1] * DriftVelocity_1[neighbourIndex], dirToNeighbour);

            volumeFracGradient_0 += dirToNeighbour * (mass / neighbourDensity)
                * (neighbourVolumeFrac_0 - VolumeFraction[particleIndex][0]) * SpikyKernelPow2(dst, smoothingRadius);
            volumeFracGradient_1 += dirToNeighbour * (mass / neighbourDensity)
                * (neighbourVolumeFrac_1 - VolumeFraction[particleIndex][1]) * SpikyKernelPow2(dst, smoothingRadius);
        }
    }

    volumeFracRate[0] = -AggregateMotion[0] - Discrepancy[0] - dot(volumeFracGradient_0, Velocities[particleIndex]);
    volumeFracRate[1] = -AggregateMotion[1] - Discrepancy[1] - dot(volumeFracGradient_1, Velocities[particleIndex]);
    return volumeFracRate;
}

void UpdateVolumeFracRate(uint particleIndex)
{
    float minFraction = 0.0000001;
    float2 newVolumeFrac = VolumeFraction[particleIndex] + VolumeFractionRate[particleIndex] * deltaTime;
    newVolumeFrac = float2(max(0.0, newVolumeFrac[0]), max(0.0, newVolumeFrac[1]));

    if (newVolumeFrac[0] < minFraction && newVolumeFrac[1] < minFraction)
    {
        newVolumeFrac[0] = minFraction;
        newVolumeFrac[1] = minFraction;
    }

    float sum = newVolumeFrac[0] + newVolumeFrac[1];
    newVolumeFrac = newVolumeFrac / sum; //Rescale to 1
    float2 deltaVolumeFrac = newVolumeFrac - VolumeFraction[particleIndex];
    VolumeFraction[particleIndex] = newVolumeFrac; // update volume fraction
    float deltaPressure = (-pressureMultiplier) * dot(deltaVolumeFrac, phaseDensity);
    PressureDelta[particleIndex] += deltaPressure;

    Mass[particleIndex] = dot(phaseMass, VolumeFraction[particleIndex]);
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalculateDriftVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;

    CalcDriftVelocity(id.x);
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalculateVolumeFraction(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;

    VolumeFractionRate[id.x] = CalculateVolumeFracRate(id.x);
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateVolumeFraction(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;

    UpdateVolumeFracRate(id.x);
}

[numthreads(ThreadGroupSize,1,1)]
void CalculateCMT (uint3 id : SV_DispatchThreadID) //CMT: convective momentum transfer (T_Dm)
{
	if (id.x >= numParticles) return;
		
	float3 pos = PredictedPositions[id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density_m = dot(VolumeFraction[id.x], phaseDensity);
	float3 CMTForce = 0;
	float3 u_m0i = DriftVelocity_0[id.x];
	float3 u_m1i = DriftVelocity_1[id.x];  

	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;

			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;

			float3 neighbourPos = PredictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			float dst = sqrt(sqrDstToNeighbour);
			float3 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float3(0.0, 1.0, 0.0);

			float3 neighbourVelocity = Velocities[neighbourIndex];
			float neighbourDensity = Densities[neighbourIndex][0];
			float3 u_m0j = DriftVelocity_0[neighbourIndex];
			float3 u_m1j = DriftVelocity_1[neighbourIndex];
			float3 CMT_term1 = 
			phaseDensity[0]*(VolumeFraction[neighbourIndex][0] * u_m0j * dot(dirToNeighbour, u_m0j) * SpikyKernelPow2(dst, smoothingRadius)
							+ VolumeFraction[id.x][0] * u_m0i * dot(dirToNeighbour, u_m0i) * SpikyKernelPow2(dst, smoothingRadius));
			float3 CMT_term2 = 
			phaseDensity[1]*(VolumeFraction[neighbourIndex][1] * u_m1j * dot(dirToNeighbour, u_m1j) * SpikyKernelPow2(dst, smoothingRadius)
							+ VolumeFraction[id.x][1] * u_m1i * dot(dirToNeighbour, u_m1i) * SpikyKernelPow2(dst, smoothingRadius));

			CMTForce += (mass/neighbourDensity) * (CMT_term1 + CMT_term2);
		}

	}
	Velocities[id.x] += (CMTForce / density_m) * deltaTime;
	Acceleration[id.x] -= (CMTForce / density_m);
}
